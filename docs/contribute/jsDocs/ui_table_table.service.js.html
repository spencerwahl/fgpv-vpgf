<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: ui/table/table.service.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: ui/table/table.service.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @module tableService
 * @memberof app.ui
 * @description
 *
 * The `tableService` is responsible for filtering DataTable results by the users current
 * extent (if enabled).
 *
 */
angular
    .module('app.ui')
    .factory('tableService', tableService);

function tableService(stateManager, geoService, $rootScope, $q, gapiService, debounceService, $rootElement, $timeout,
    referenceService, layerRegistry, configService, Geo, events) {

    // timestamps can be watched for key changes to filter data
    const filterTimeStamps = {
        onCreated: null,
        onChanged: null,
        onDeleted: null
    };

    // a list of valid oidField values after filtering is complete
    let validOIDs = [];

    // the numerical index of DataTables corresponding row oidField for the range filter
    let oidColNum;

    const service = {
        setActive,
        filterTimeStamps,
        filter: {
            isActive: false,
            isApplied: true,
            isMapFiltered: false,
            isOpen: true
        },
        setTable,
        getTable,
        clearFilters,
        applyFilters,
        openSettings,
        onFilterStringChange: debounceService.registerDebounce(onFilterStringChange, 700, false),
        onFilterSelectorChange: onFilterSelectorChange,
        onFilterNumberChange: debounceService.registerDebounce(onFilterNumberChange, 700, false),
        onFilterDateChange: onFilterDateChange,
        preventSorting: preventSorting,
        filters: {},
        isFeatureLayer: false,
        isDynamicLayer: false,
        isSettingOpen: false,
        isGlobalSearch: false
    };

    // active table for global search to link to
    let activeTable;

    // array who contains filters (use to show/hide apply on map button)
    let filtersObject;

    init();

    return service;

    /**
     * Enables/Disables filtering by extent.
     *
     * @function setActive
     * @param   {Boolean}   value   true if extent filtering is enabled, false otherwise
     */
    function setActive(value) {
        if (filterTimeStamps.onCreated !== null) { // ignore if no DataTable is active
            service.filter.isActive = value;
            stateManager.display.table.data.filter.isActive = value; // set on layer so it can persist when we change layer

            // filter flag
            stateManager.display.table.requester.legendEntry.filter = service.filter.isMapFiltered;

            filteredState().then(() => {
                filterTimeStamps.onChanged = Date.now();
            });
        }
    }

    /**
     * Initialize watchers and DataTable range filter
     *
     * @function init
     * @private
     */
    function init() {

        events.$on(events.rvSymbDefinitionQueryChanged, () => {
            if (filterTimeStamps.onCreated !== null) {
                filteredState().then(() => {
                    filterTimeStamps.onChanged = Date.now();
                });
            }
        });

        $rootScope.$on('extentChange', debounceService.registerDebounce(onExtentChange, 300, false));

        // DataTable is either being created or destroyed
        $rootScope.$watch(() => stateManager.display.table.data, (val, prevVal) => {
            // triggered on DataTable panel close or switching from one layer to another
            if ((val === null &amp;&amp; prevVal &amp;&amp; prevVal.rows) || (val &amp;&amp; val.rows &amp;&amp; prevVal &amp;&amp; prevVal.rows)) {
                onDestroy();
            }
            // triggered on DataTable panel open
            if (val &amp;&amp; val.rows) {
                onCreate();
            }
        });
    }

    /**
     * Set active table
     *
     * @function setTable
     * @param   {Object}   table   active table
     */
    function setTable(table) {
        activeTable = table;

        // determine if to show global search
        const configTable = stateManager.display.table.requester.legendEntry.proxyWrapper.layerConfig.table;
        service.isGlobalSearch = configTable.search.enabled;

        // reset all filters state to false (they will be populated by the loading table)
        filtersObject = table.columns().dataSrc();
        filtersObject.each(el => {
            service.filters[el] = false;
        });

        // recompute oidColNum for data table filter since it may not be first index
        oidColNum = stateManager.display.table.data.columns.findIndex(col =>
            col.data === stateManager.display.table.data.oidField);

        // add a DataTable filter which only accepts rows with oidField values in the validOIDs list
        $.fn.dataTable.ext.searchTemp.push((settings, data) =>
            validOIDs.indexOf(parseInt(data[settings._colReorder.fnTranspose(oidColNum)])) !== -1);
    }

    /**
     * Get active table
     *
     * @function getTable
     * @return   {Object}  activeTable the active table
     */
    function getTable() {
        return activeTable;
    }

    /**
     * Clear all filters
     *
     * @function clearFilters
     */
    function clearFilters() {
        const filters = stateManager.display.table;
        const table = service.getTable();

        // show processing
        $rootElement.find('.dataTables_processing').css('display', 'block');

        // set isApplied to hide apply filters on map button
        service.filter.isApplied = true;
        filters.data.filter.isApplied = service.filter.isApplied;  // set on layer so it can persist when we change layer

        // reset global search ($watch in filters-search.directive will remove the value)
        stateManager.display.table.data.filter.globalSearch = '_reset_';

        // reset all filters state to false
        filtersObject.each(el => {
            service.filters[el] = false;
        });

        // reset all filters value to default
        let defs = [];
        let filter = false;
        filters.data.columns.forEach(column => {
            // skip columns with no filter
            if (typeof column.filter !== 'undefined') {
                if (!column.filter.static) {
                    if (column.type === 'string') {
                        column.filter.value = '';
                        table.column(`${column.data}:name`).search('');
                    } else if (column.type === 'selector') {
                        column.filter.value = [];
                        table.column(`${column.data}:name`).search('');
                    } else if (column.type === 'number') {
                        column.filter.min = '';
                        column.filter.max = '';
                    } else if (column.type === 'date') {
                        column.filter.min = null;
                        column.filter.max = null;
                    }
                } else {
                    // if filter is static, apply the value
                    defs = getFilterDefintion(defs, column);
                    filter = true;
                }
            }
        });

        const layerConfig = filters.requester.legendEntry.proxyWrapper.layerConfig;

        // store the reset filter values
        layerConfig.table.columns.forEach(column => {
            if (typeof column.filter !== 'undefined') {
                if (!column.filter.static) {
                    if (column.filter.type === 'selector') {
                        column.filter.value = [];
                    } else if (column.filter.type === 'date') {
                        column.filter.value = {};
                    } else {
                        column.filter.value = '';
                    }
                }
            }
        });

        // remove filter flag if filter by extent is not active (data is not filtered)
        service.filter.isMapFiltered = false;
        filters.data.filter.isMapFiltered = service.filter.isMapFiltered;  // set on layer so it can persist when we change layer

        let config = configService.getSync.map.layerRecords.find(item =>
            item.config.id === filters.requester.legendEntry.layerRecordId).initialConfig;

        // TODO: Modify when filtering capabilities added for other layers such as WMS
        if (config.layerType === Geo.Layer.Types.ESRI_DYNAMIC) {
            config = config.layerEntries.find(item => item.index === layerConfig.index)
        }

        config.table.applyMap = false;

        // most recent 'filters' were applied (no filters but no changes either)
        config.table.applied = true;

        // update the query to use on layer reload
        config.initialFilteredQuery = defs.join(' AND ');

        // get filters configuration and check if static field were used. If so, filters can't be remove and flag need to stay
        stateManager.display.table.requester.legendEntry.filter =
            service.filter.isMapFiltered || filter;

        // if filter by extent is enable, manually trigger the on extentChange event to refresh the table
        if (service.filter.isActive) { onExtentChange(); }

        // redraw table to clear filters (use timeout for redraw so processing can show)
        $timeout(() => { table.search('').draw(); }, 100);

        // set layer defintion query
        setDefinitionExpression(filters.requester.legendEntry, defs);
    }

    /**
     * Apply filters on map
     *
     * @function applyFilters
     */
    function applyFilters() {
        const filters = stateManager.display.table;

        // set isApplied to hide apply filters on map button
        service.filter.isApplied = true;
        filters.data.filter.isApplied = service.filter.isApplied;  // set on layer so it can persist when we change layer

        // loop trought all the filters to construct the array queries
        let defs = [];
        filters.data.columns.forEach(column => {
            // skip columns with no filter
            if (typeof column.filter !== 'undefined') {
                defs = getFilterDefintion(defs, column);
            }
        });

        // set layer defintion query
        setDefinitionExpression(filters.requester.legendEntry, defs);

        const layerConfig = filters.requester.legendEntry.proxyWrapper.layerConfig;

        if (defs.length === 0) {
            // store the reset filter values
            layerConfig.table.columns.forEach(column => {
                if (typeof column.filter !== 'undefined') {
                    if (column.filter.type === 'selector') {
                        column.filter.value = [];
                    } else if (column.filter.type === 'date') {
                        column.filter.value = {};
                    } else {
                        column.filter.value = '';
                    }
                }
            });
        }

        // set filter flag accordingly (if data is filtered)
        service.filter.isMapFiltered = defs.length > 0;
        filters.data.filter.isMapFiltered = service.filter.isMapFiltered;  // set on layer so it can persist when we change layer

        let config = configService.getSync.map.layerRecords.find(item =>
            item.config.id === filters.requester.legendEntry.layerRecordId).initialConfig;

        // TODO: Modify when filtering capabilities added for other layers such as WMS
        if (config.layerType === Geo.Layer.Types.ESRI_DYNAMIC) {
            config = config.layerEntries.find(item => item.index === layerConfig.index)
        }

        // most recent 'filters' were applied (either no filters and no changes or updated filters applied)
        config.table.applyMap = config.table.applied = true;

        stateManager.display.table.requester.legendEntry.filter = service.filter.isMapFiltered;

        // update the query to use on layer reload
        config.initialFilteredQuery = defs.join(' AND ');
    }

    /**
     * Get the layer definition query
     *
     * @function getFilterDefintion
     * @private
     * @param   {Array}   defs   array of definition queries
     * @param   {Object}   column   column object
     * @return {Array} defs definition queries array
     */
    // eslint-disable-next-line complexity
    function getFilterDefintion(defs, column) {
        /*jshint maxcomplexity:11 */
        if (column.type === 'string') {
            // replace ' by '' to be able to perform the search in the datatable
            // relpace * wildcard and construct the query (add wildcard at the end)
            const configTable = stateManager.display.table.requester.legendEntry.proxyWrapper.layerConfig.table;
            let val = column.filter.value.replace(/'/g, /''/);
            if (configTable.lazyFilter) {
                const filterVal = `*${val}`;
                val = filterVal.split(" ").join("*");
            }
            if (val !== '') {
                defs.push(`UPPER(${column.name}) LIKE \'${val.replace(/\*/g, '%').toUpperCase()}%\'`);
            }
        }

         if (column.type === 'selector') {
            const val =  column.filter.value.join(`' , '`);
            if (val !== '') {
                defs.push(`UPPER(${column.name}) IN (\'${val.toUpperCase()}\')`);
            }
        } else if (column.type === 'number') {
            const min = column.filter.min;
            const max = column.filter.max;

            if (min !== '') {
                defs.push(`${column.name} >= ${min}`);
            }
            if (max !== '') {
                defs.push(`${column.name} &lt;= ${max}`);
            }
        } else if (column.type === 'date') {
            const min = new Date(column.filter.min);
            const max = new Date(column.filter.max);

            if (min) {
                const dateMin = `${min.getMonth() + 1}/${min.getDate()}/${min.getFullYear()}`;
                defs.push(`${column.name} >= DATE \'${dateMin}\'`);
            }
            if (max) {
                const dateMax = `${max.getMonth() + 1}/${max.getDate()}/${max.getFullYear()}`;
                defs.push(`${column.name} &lt;= DATE \'${dateMax}\'`);
            }
        }

        return defs;
    }

    /**
     * Set the layer definition query
     *
     * @function setDefinitionExpression
     * @private
     * @param   {Object}   legendEntry   legendEntry item to get layer from
     * @param   {Array}   defs   array of definition queries to apply
     */
    function setDefinitionExpression(legendEntry, defs) {
        // stringnify the array
        const definition = defs.join(' AND ');
        const legendBlock = stateManager.display.table.requester.legendEntry;

        // add table query to block for symbology access
        legendBlock.tableDefinitionQuery = definition;

        // determine query definition based on symbology and table queries
        let fullDef = legendBlock.symbDefinitionQuery
                    ? definition
                        ? `(${definition}) AND (${legendBlock.symbDefinitionQuery})`
                        : legendBlock.symbDefinitionQuery
                    : definition;

        // apply to block so changes reflect on map
        legendBlock.definitionQuery = fullDef;
    }

    /**
     * Open settings info section
     *
     * @function openSettings
     */
    function openSettings() {
        service.isSettingOpen = !service.isSettingOpen;

        // show filters if setting is open
        if (service.isSettingOpen) {
            referenceService.isFiltersVisible = true;
        } else {
            // when setting is close, check if we need to show setting
            referenceService.isFiltersVisible = service.filter.isOpen;

            // need to recalculate scroller space because user may have switch from default to full view inside setting panel
            // need a timeout, if not measure occurs when datatable is not displayed and it fails
            $timeout(() => { activeTable.scroller.measure(); }, 0);
        }
    }

    /**
     * Apply on string filter change callback
     *
     * @function onFilterStringChange
     * @param   {String}   column   column name
     * @param   {String}   value   search filter
     * @param   {Boolean}  [keep=false]    optional true: keep value for filter, false do not keep
     */
    function onFilterStringChange(column, value, keep = false) {
        // show processing
        $rootElement.find('.dataTables_processing').css('display', 'block');

        const configTable = stateManager.display.table.requester.legendEntry.proxyWrapper.layerConfig.table;

        // generate regex then filter (use timeout for redraw so processing can show) or use lazy filter if set in config
        let val = `^${value.replace(/\*/g, '.*')}.*$`;
        if (configTable.lazyFilter) {
            const filterVal = `[\\w,\\s]*${value.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&amp;')}`;
            val = filterVal.split(" ").join("[\\w,\\s]*");
        }
        const table = service.getTable();
        $timeout(() => { table.column(`${column}:name`).search(val, true, false).draw(); }, 100);

        // keep filter state to know when to show apply map button
        setFiltersState(column, value);

        // keep filter value to reapply when table reopens
        configTable.columns.find(filter => column === filter.data).filter.value = value;

        // changes made to filter, show Apply Map button
        configTable.applyMap = configTable.applied = false;
    }

    /**
     * Apply on selector filter change callback
     *
     * @function onFilterSelectorChange
     * @param   {String}   column   column name
     * @param   {Array}   values   search filter array
     */
    function onFilterSelectorChange(column, values) {
        // join the values by | for or and remove all ". They are use to split the values
        const value = (values.length > 0) ? values.join('|').replace(/"/g, '') : '';
        onFilterStringChange(column, value);

        const configTable = stateManager.display.table.requester.legendEntry.proxyWrapper.layerConfig.table;

        // keep filter value when reloading layer
        configTable.columns.find(filter => column === filter.data).filter.value = values;

        // changes made to filter, show Apply Map button
        configTable.applyMap = configTable.applied = false;
    }

    /**
     * Apply on number filter change callback
     *
     * @function onFilterNumberChange
     * @param   {String}   column   column name
     * @param   {Number}   min   minimum number search filter
     * @param   {Number}   max   maximum number search filter
     */
    function onFilterNumberChange(column, min, max) {
        // show processing
        $rootElement.find('.dataTables_processing').css('display', 'block');

        // keep filter state to know when to show apply map button
        setFiltersState(column, `${min}${max}`);

        // redraw table to filter (filters for range number are added on the table itself in table-definition.directive)
        // use timeout for redraw so processing can show
        $timeout(() => { service.getTable().draw(); }, 100);

        const configTable = stateManager.display.table.requester.legendEntry.proxyWrapper.layerConfig.table;

        // keep filter value when reloading layer
        configTable.columns.find(filter => column === filter.data).filter.value = `${min},${max}`;

        // changes made to filter, show Apply Map button
        configTable.applyMap = configTable.applied = false;
    }

    /**
     * Apply on date filter change callback
     *
     * @function onFilterDateChange
     * @param   {String} column   column name
     * @param   {Date}   min   minimum date search filter
     * @param   {Date}   max   maximum date search filter
     */
    function onFilterDateChange(column, min, max) {
        // show processing
        $rootElement.find('.dataTables_processing').css('display', 'block');

         // keep filter state to know when to show apply map button
        setFiltersState(column, `${min}${max}`);

        // redraw table to filter (filters for range date are added on the table itself in table-definition.directive)
        // use timeout for redraw so processing can show
        $timeout(() => { service.getTable().draw(); }, 100);

        const configTable = stateManager.display.table.requester.legendEntry.proxyWrapper.layerConfig.table;

        // keep filter value when reloading layer
        configTable.columns.find(filter => column === filter.data).filter.value = {
            min: min,
            max: max
        };

        // changes made to filter, show Apply Map button
        configTable.applyMap = configTable.applied = false;
    }

    /**
     * Set filters state on filters modification to know when show/hide apply on map button
     *
     * @function setFilterState
     * @private
     * @param   {String}   column   column name
     * @param   {String}   value   search filter value
     */
    function setFiltersState(column, value) {
        // if there is value, assign to column and show apply map button
        // if not, it means value is '', loop through the filters to see if we still need to show apply map button
        if (value) {
            service.filters[column] = true;
            service.filter.isApplied = false;
        } else {
            service.filters[column] = false;

            // check filter flag to know if filter is applied
            service.filter.isApplied = stateManager.display.table.requester.legendEntry.filters ? false : true;

            let flag = false;

            filtersObject.each(el => {
                // check if another field have a filter. If so, show Apply Map
                if (service.filters[el]) {
                    flag = true;
                    service.filter.isApplied = false;
                }
            });

            // if flag is still false, no other field has a filter, so all filters have been cleared on table
            // show Apply Map button to be able to clear all filters on the map as well
            if (flag === false) {
                service.filter.isApplied = false;
            }
        }

        stateManager.display.table.data.filter.isApplied = service.filter.isApplied;  // set on layer so it can persist when we change layer
    }

    /**
     * Prevent column sort when filter is clicked
     *
     * @function preventSorting
     * @param   {Object} event   event fired when user click or press a key on a filter
     */
    function preventSorting(event) {
        if (event.type === 'click' || (event.type === 'keypress' &amp;&amp; event.which === 13)) {
            event.stopPropagation(true);
            event.preventDefault(true);
        }
    }

    /**
     * Called when filter panel data is being added.
     *
     * @function onCreate
     * @private
     */
    function onCreate() {
        // recompute oidColNum for data table filter since it may not be first index
        oidColNum = stateManager.display.table.data.columns.findIndex(col =>
            col.data === stateManager.display.table.data.oidField);

        // set filter flag
        service.filter.isActive = stateManager.display.table.requester.legendEntry.filters

        // set filter extent and apply map button from table information
        const filter = stateManager.display.table.data.filter;
        service.filter.isActive = filter.isActive;
        service.filter.isApplied = filter.isApplied;
        service.filter.isMapFiltered = filter.isMapFiltered;
        service.filter.isOpen = filter.isOpen;

        // check if we need to show the filters (need this check when table is created)
        // always show filters if settings panel is open
        referenceService.isFiltersVisible = service.isSettingOpen ? true : service.filter.isOpen;

        // set layer type to see if we show apply filter button. Only works on feature/dynamic layer
        // user added layer (layer created by value from a feature collection like CSV file) does not support definition expressions and time definitions)
        // user added layer from server support definition expression and time defintion
        const layer = layerRegistry.getLayerRecord(stateManager.display.table.requester.legendEntry.layerRecordId);
        const layerType = layer.initialConfig.layerType; // stateManager.display.table.requester.legendEntry.layerType;
        service.isFeatureLayer = (layerType === Geo.Layer.Types.ESRI_FEATURE &amp;&amp; layer.dataSource() === 'esri');
        service.isDynamicLayer = (layerType === Geo.Layer.Types.ESRI_DYNAMIC);

        filteredState().then(() => {
            filterTimeStamps.onCreated = Date.now();
        });
    }

    /**
     * Called when filter panel data is being removed or swapped.
     *
     * @function onDestroy
     * @private
     */
    function onDestroy() {
        filterTimeStamps.onDeleted = Date.now();
        filterTimeStamps.onCreated = null;
        filterTimeStamps.onChanged = null;

        // reset global search to hidden
        service.isGlobalSearch = false;
    }

    /**
     * Called on map extent changes. Locates updating layer and waits for updating to complete before
     * running filtering.
     *
     * @function onExtentChange
     * @private
     */
    function onExtentChange() {
        if (!service.filter.isActive || !stateManager.display.table.requester) { // filter by extent disabled or no DataTable is active - ignore
            return;
        }

        const layer =
            layerRegistry.getLayerRecord(stateManager.display.table.requester.legendEntry.layerRecordId)._layer;

        // wait until layer has finished updating before filtering
        const stopUpdateWatcher = $rootScope.$watch(() => layer.updating, updating => {
            if (!updating) {
                filteredState().then(() => {
                    filterTimeStamps.onChanged = Date.now();
                });
                stopUpdateWatcher(); // remove watcher
            }
        });
    }

    /**
     * Applies validOIDs returned from queryMap or all oids if no query is applied.
     *
     * @function filteredState
     * @private
     * @return  {Promise}   resolves to undefined when the filtering is complete
     */
    function filteredState() {
        const legendBlock = stateManager.display.table.requester.legendEntry;

        // we're not filtering by either symbology or extent, so resolve with all oid's as valid
        if (!service.filter.isActive &amp;&amp; typeof legendBlock.symbDefinitionQuery !== 'string') {
            validOIDs = stateManager.display.table.data.rows.map(row => parseInt(row[stateManager.display.table.data.oidField]));
            return $q.resolve();
        }

        return queryMapserver().then(oids => (validOIDs = oids));
    }

    /**
     * Performs an ESRI query for all features with a spatial intersection with the current extent.
     *
     * @function queryMapserver
     * @private
     * @param   {Number}    lastOID the oidField value of the last query when exceededTransferLimit is reached
     * @return  {Promise}   resolves to a list of valid oid's
     */
    function queryMapserver(lastOID = 0) {
        const state = stateManager.display.table;
        const legEntry = state.requester.legendEntry;
        const layerRecId = layerRegistry.getLayerRecord(legEntry.layerRecordId);

        const filterByExtent = service.filter.isActive;
        const filterBySymbology = typeof legEntry.symbDefinitionQuery === 'string';

        const queryOpts = { outFields: [state.data.oidField] };
        if (filterByExtent) {
            queryOpts.geometry = geoService.map.extent;
        }

        // query the layer itself instead of making a mapserver request
        if (legEntry.parentLayerType === 'esriFeature' &amp;&amp; legEntry.layerType === 'esriFeature' &amp;&amp; layerRecId.dataSource() !== 'esri') {
            queryOpts.featureLayer = layerRecId._layer;         // file based layer
        } else {
            queryOpts.url = legEntry.proxyWrapper.queryUrl;        // server based layer
        }

        // only include oidField values after previous mapserver query resulted in a exceededTransferLimit exception
        if (lastOID > 0) {
            queryOpts.where = `(${state.data.oidField} > ${lastOID})`;

            if (filterBySymbology) {
                queryOpts.where += ` AND `;
            }
        } else {
            queryOpts.where = ''; // this is needed for our string concatenation below, else its undefined
        }


        if (filterBySymbology) {
            queryOpts.where += `(${legEntry.symbDefinitionQuery})`;
        }

        return gapiService.gapi.query.queryGeometry(queryOpts).then(featureSet => {
            // save an array of OID's returned by the query
            const validOIDs = featureSet.features.map(feat => parseInt(feat.attributes[state.data.oidField]));
            // transfer limit exceeded - call query again until all data is retrieved
            if (featureSet.exceededTransferLimit) {
                // get the last oidField value to use as a starting point for another query
                // TODO: Using the assumption that oidField values are sorted. If this turns out to be not the case,
                // see the available ESRI methods orderByFields or start (would need to expose in geoAPI first)
                const lastOID = featureSet.features[featureSet.features.length - 1].attributes[state.data.oidField];
                return queryMapserver(lastOID).then(oIDs => validOIDs.concat(oIDs)); // merge recursive list with own results
            } else { // either query did not trigger an exceededTransferLimit exception, or this marks the end of the result set
                return validOIDs;
            }
        });
    }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="app.common.module_displayManager.html">displayManager</a></li><li><a href="app.common.module_stateManager.html">stateManager</a></li><li><a href="app.core.module_common.html">common</a></li><li><a href="app.core.module_ConfigObject.html">ConfigObject</a></li><li><a href="app.core.module_configService.html">configService</a></li><li><a href="app.geo.module_gapiService.html">gapiService</a></li><li><a href="app.geo.module_Geo.html">Geo</a></li><li><a href="app.geo.module_geoService.html">geoService</a></li><li><a href="app.geo.module_identifyService.html">identifyService</a></li><li><a href="app.geo.module_layerRegistry.html">layerRegistry</a></li><li><a href="app.geo.module_LegendBlock.html">LegendBlock</a></li><li><a href="app.geo.module_LegendElementFactory.html">LegendElementFactory</a></li><li><a href="app.geo.module_legendService.html">legendService</a></li><li><a href="app.geo.module_locateService.html">locateService</a></li><li><a href="app.geo.module_mapService.html">mapService</a></li><li><a href="app.geo.module_mapToolService.html">mapToolService</a></li><li><a href="app.geo.module_metadataService.html">metadataService</a></li><li><a href="app.geo.module_rvInitMap.html">rvInitMap</a></li><li><a href="app.geo.module_rvOverviewToggle.html">rvOverviewToggle</a></li><li><a href="app.layout.module_animationService.html">animationService</a></li><li><a href="app.layout.module_layoutService.html">layoutService</a></li><li><a href="app.layout.module_referenceService.html">referenceService</a></li><li><a href="app.layout.module_rvShell.html">rvShell</a></li><li><a href="app.module_core.html">core</a></li><li><a href="app.module_ui.html">ui</a></li><li><a href="app.ui.module_basemapService.html">basemapService</a></li><li><a href="app.ui.module_detailService.html">detailService</a></li><li><a href="app.ui.module_errorService.html">errorService</a></li><li><a href="app.ui.module_expandImageService.html">expandImageService</a></li><li><a href="app.ui.module_ExportComponent.html">ExportComponent</a></li><li><a href="app.ui.module_exportComponentsService.html">exportComponentsService</a></li><li><a href="app.ui.module_exportGenerators.html">exportGenerators</a></li><li><a href="app.ui.module_ExportSize.html">ExportSize</a></li><li><a href="app.ui.module_exportSizesService.html">exportSizesService</a></li><li><a href="app.ui.module_fullScreenService.html">fullScreenService</a></li><li><a href="app.ui.module_geosearchFiltersService.html">geosearchFiltersService</a></li><li><a href="app.ui.module_geosearchService.html">geosearchService</a></li><li><a href="app.ui.module_helpService.html">helpService</a></li><li><a href="app.ui.module_highlightFilter.html">highlightFilter</a></li><li><a href="app.ui.module_layerSource.html">layerSource</a></li><li><a href="app.ui.module_mapNavigationService.html">mapNavigationService</a></li><li><a href="app.ui.module_rvAppbar.html">rvAppbar</a></li><li><a href="app.ui.module_rvBasemap.html">rvBasemap</a></li><li><a href="app.ui.module_rvBasemapItem.html">rvBasemapItem</a></li><li><a href="app.ui.module_rvContentPane.html">rvContentPane</a></li><li><a href="app.ui.module_rvDetails.html">rvDetails</a></li><li><a href="app.ui.module_rvDetailsContent.html">rvDetailsContent</a></li><li><a href="app.ui.module_rvDetailsHeader.html">rvDetailsHeader</a></li><li><a href="app.ui.module_rvDetailsRecordEsrifeature.html">rvDetailsRecordEsrifeature</a></li><li><a href="app.ui.module_rvDetailsRecordEsrifeatureItem.html">rvDetailsRecordEsrifeatureItem</a></li><li><a href="app.ui.module_rvDetailsRecordHtml.html">rvDetailsRecordHtml</a></li><li><a href="app.ui.module_rvDetailsRecordText.html">rvDetailsRecordText</a></li><li><a href="app.ui.module_rvDetectScrollbar.html">rvDetectScrollbar</a></li><li><a href="app.ui.module_rvDragula.html">rvDragula</a></li><li><a href="app.ui.module_rvExportCustomSize.html">rvExportCustomSize</a></li><li><a href="app.ui.module_rvGeosearch.html">rvGeosearch</a></li><li><a href="app.ui.module_rvGeosearchBar.html">rvGeosearchBar</a></li><li><a href="app.ui.module_rvGeosearchBottomFilters.html">rvGeosearchBottomFilters</a></li><li><a href="app.ui.module_rvGeosearchTopFilters.html">rvGeosearchTopFilters</a></li><li><a href="app.ui.module_rvHelpOverlay.html">rvHelpOverlay</a></li><li><a href="app.ui.module_rvHelpSearch.html">rvHelpSearch</a></li><li><a href="app.ui.module_rvLayerListSlider.html">rvLayerListSlider</a></li><li><a href="app.ui.module_rvLegendBlock.html">rvLegendBlock</a></li><li><a href="app.ui.module_rvLoaderFile.html">rvLoaderFile</a></li><li><a href="app.ui.module_rvLoaderMenu.html">rvLoaderMenu</a></li><li><a href="app.ui.module_rvMapnav.html">rvMapnav</a></li><li><a href="app.ui.module_rvMapnavButton.html">rvMapnavButton</a></li><li><a href="app.ui.module_rvMenuLink.html">rvMenuLink</a></li><li><a href="app.ui.module_rvMetadataContent.html">rvMetadataContent</a></li><li><a href="app.ui.module_rvMetadataExpand.html">rvMetadataExpand</a></li><li><a href="app.ui.module_rvMetadataPanel.html">rvMetadataPanel</a></li><li><a href="app.ui.module_rvMorph.html">rvMorph</a></li><li><a href="app.ui.module_rvPlugSlide.html">rvPlugSlide</a></li><li><a href="app.ui.module_rvReverse.html">rvReverse</a></li><li><a href="app.ui.module_rvSettings.html">rvSettings</a></li><li><a href="app.ui.module_rvSettingsContent.html">rvSettingsContent</a></li><li><a href="app.ui.module_rvSidenav.html">rvSidenav</a></li><li><a href="app.ui.module_rvStepperItem.html">rvStepperItem</a></li><li><a href="app.ui.module_rvSymbologyStack.html">rvSymbologyStack</a></li><li><a href="app.ui.module_rvTableDefault.html">rvTableDefault</a></li><li><a href="app.ui.module_rvTableDefaultMenu.html">rvTableDefaultMenu</a></li><li><a href="app.ui.module_rvTablePanel.html">rvTablePanel</a></li><li><a href="app.ui.module_rvToc.html">rvToc</a></li><li><a href="app.ui.module_rvTocEntryControl.html">rvTocEntryControl</a></li><li><a href="app.ui.module_rvTocExpandMenu.html">rvTocExpandMenu</a></li><li><a href="app.ui.module_rvTocVisibilityMenu.html">rvTocVisibilityMenu</a></li><li><a href="app.ui.module_rvToggleSlide.html">rvToggleSlide</a></li><li><a href="app.ui.module_rvToolbox.html">rvToolbox</a></li><li><a href="app.ui.module_rvTooltip.html">rvTooltip</a></li><li><a href="app.ui.module_rvTruncate.html">rvTruncate</a></li><li><a href="app.ui.module_sideNavigationService.html">sideNavigationService</a></li><li><a href="app.ui.module_StepperFactory.html">StepperFactory</a></li><li><a href="app.ui.module_SymbologyStack.html">SymbologyStack</a></li><li><a href="app.ui.module_tableService.html">tableService</a></li><li><a href="app.ui.module_tocService.html">tocService</a></li><li><a href="app.ui.module_tooltipService.html">tooltipService</a></li><li><a href="material.components.button.module_MdButtonDirectiveDecorator.html">MdButtonDirectiveDecorator</a></li><li><a href="material.components.dialog.module_$mdDialog.html">$mdDialog</a></li><li><a href="material.components.icon.module_mdIconDirectiveDecorator.html">mdIconDirectiveDecorator</a></li><li><a href="material.components.menu.module_mdMenuDirective.html">mdMenuDirective</a></li><li><a href="material.components.menu.module_mdSelectDirective.html">mdSelectDirective</a></li><li><a href="material.components.menuBar.module_mdMenuItemDirectiveDecorator.html">mdMenuItemDirectiveDecorator</a></li><li><a href="material.components.select.module_mdSelectMenuDirective.html">mdSelectMenuDirective</a></li><li><a href="material.components.tooltip.module_mdTooltipDirective.html">mdTooltipDirective</a></li></ul><h3>Classes</h3><ul><li><a href="app.core.module_ConfigObject-About.html">About</a></li><li><a href="app.core.module_ConfigObject-Basemap.html">Basemap</a></li><li><a href="app.core.module_ConfigObject-ConfigObject.html">ConfigObject</a></li><li><a href="app.core.module_ConfigObject-Entry.html">Entry</a></li><li><a href="app.core.module_ConfigObject-ExportComponent.html">ExportComponent</a></li><li><a href="app.core.module_ConfigObject-ExportService.html">ExportService</a></li><li><a href="app.core.module_ConfigObject-ExtentSet.html">ExtentSet</a></li><li><a href="app.core.module_ConfigObject-Help.html">Help</a></li><li><a href="app.core.module_ConfigObject-InfoSection.html">InfoSection</a></li><li><a href="app.core.module_ConfigObject-InitialLayerSettings.html">InitialLayerSettings</a></li><li><a href="app.core.module_ConfigObject-LayerNode.html">LayerNode</a></li><li><a href="app.core.module_ConfigObject-Legend.html">Legend</a></li><li><a href="app.core.module_ConfigObject-LegendExportComponent.html">LegendExportComponent</a></li><li><a href="app.core.module_ConfigObject-LegendIsOpen.html">LegendIsOpen</a></li><li><a href="app.core.module_ConfigObject-LodSet.html">LodSet</a></li><li><a href="app.core.module_ConfigObject-Map.html">Map</a></li><li><a href="app.core.module_ConfigObject-NavBar.html">NavBar</a></li><li><a href="app.core.module_ConfigObject-Services.html">Services</a></li><li><a href="app.core.module_ConfigObject-SideMenu.html">SideMenu</a></li><li><a href="app.core.module_ConfigObject-StartPoint.html">StartPoint</a></li><li><a href="app.core.module_ConfigObject-TableIsOpen.html">TableIsOpen</a></li><li><a href="app.core.module_ConfigObject-TileSchema.html">TileSchema</a></li><li><a href="app.core.module_ConfigObject-UI.html">UI</a></li><li><a href="app.core.module_ConfigObject-UILegend.html">UILegend</a></li><li><a href="app.core.module_ConfigObject-VisibilitySet.html">VisibilitySet</a></li><li><a href="app.core.module_configService-Config.html">Config</a></li><li><a href="app.geo.module_LegendBlock-LegendGroup.html">LegendGroup</a></li><li><a href="app.geo.module_LegendBlock-ProxyWrapper.html">ProxyWrapper</a></li><li><a href="app.geo.module_LegendElementFactory-SymbologyControl.html">SymbologyControl</a></li><li><a href="app.ui.module_StepperFactory-Stepper.html">Stepper</a></li><li><a href="app.ui.module_SymbologyStack-SymbologyStack.html">SymbologyStack</a></li><li><a href="app.ui.module_tooltipService-ContainInside.html">ContainInside</a></li><li><a href="app.ui.module_tooltipService-FollowMap.html">FollowMap</a></li><li><a href="app.ui.module_tooltipService-FollowMouse.html">FollowMouse</a></li><li><a href="app.ui.module_tooltipService-Tooltip.html">Tooltip</a></li><li><a href="app.ui.module_tooltipService-TooltipStrategy.html">TooltipStrategy</a></li><li><a href="ConfigObject.UI.html">UI</a></li><li><a href="ExportSize.html">ExportSize</a></li><li><a href="ToggleSymbol.html">ToggleSymbol</a></li><li><a href="Viewer.html">Viewer</a></li><li><a href="ViewerGroup.html">ViewerGroup</a></li></ul><h3>Namespaces</h3><ul><li><a href="app.html">app</a></li><li><a href="app.core.html">core</a></li><li><a href="app.geo.html">geo</a></li><li><a href="app.layout.html">layout</a></li><li><a href="app.ui.html">ui</a></li></ul><h3>Global</h3><ul><li><a href="global.html#$on">$on</a></li><li><a href="global.html#_cfg">_cfg</a></li><li><a href="global.html#addViewer">addViewer</a></li><li><a href="global.html#applyDefault">applyDefault</a></li><li><a href="global.html#attachEvents">attachEvents</a></li><li><a href="global.html#autolink">autolink</a></li><li><a href="global.html#centerAndZoom">centerAndZoom</a></li><li><a href="global.html#configureParser">configureParser</a></li><li><a href="global.html#createCanvas">createCanvas</a></li><li><a href="global.html#createSvg">createSvg</a></li><li><a href="global.html#dateTimeZone">dateTimeZone</a></li><li><a href="global.html#detachEvents">detachEvents</a></li><li><a href="global.html#detectBlur">detectBlur</a></li><li><a href="global.html#detectFocus">detectFocus</a></li><li><a href="global.html#disableCommonPrototypes">disableCommonPrototypes</a></li><li><a href="global.html#elemIsFocusable">elemIsFocusable</a></li><li><a href="global.html#fireRvReady">fireRvReady</a></li><li><a href="global.html#focus">focus</a></li><li><a href="global.html#focusableSearch">focusableSearch</a></li><li><a href="global.html#getBookmark">getBookmark</a></li><li><a href="global.html#getRcsLayerIDs">getRcsLayerIDs</a></li><li><a href="global.html#getTextWidth">getTextWidth</a></li><li><a href="global.html#hasLink">hasLink</a></li><li><a href="global.html#initialBookmark">initialBookmark</a></li><li><a href="global.html#isSameActiveElement">isSameActiveElement</a></li><li><a href="global.html#isValid">isValid</a></li><li><a href="global.html#lastVisibleHistoryElement">lastVisibleHistoryElement</a></li><li><a href="global.html#link">link</a></li><li><a href="global.html#loadRcsLayers">loadRcsLayers</a></li><li><a href="global.html#mapCoordinates">mapCoordinates</a></li><li><a href="global.html#mergeCanvases">mergeCanvases</a></li><li><a href="global.html#northArrow">northArrow</a></li><li><a href="global.html#noSourceLink">noSourceLink</a></li><li><a href="global.html#onFocusin">onFocusin</a></li><li><a href="global.html#onFocusout">onFocusout</a></li><li><a href="global.html#onKeydown">onKeydown</a></li><li><a href="global.html#onKeyup">onKeyup</a></li><li><a href="global.html#onMouseDown">onMouseDown</a></li><li><a href="global.html#picture">picture</a></li><li><a href="global.html#process">process</a></li><li><a href="global.html#ready">ready</a></li><li><a href="global.html#registerPlugin">registerPlugin</a></li><li><a href="global.html#reInitialize">reInitialize</a></li><li><a href="global.html#restoreSession">restoreSession</a></li><li><a href="global.html#RV">RV</a></li><li><a href="global.html#rvCrosshairs">rvCrosshairs</a></li><li><a href="global.html#rvDefaults">rvDefaults</a></li><li><a href="global.html#rvFailureImage">rvFailureImage</a></li><li><a href="global.html#rvFocus">rvFocus</a></li><li><a href="global.html#rvNorthArrow">rvNorthArrow</a></li><li><a href="global.html#rvState">rvState</a></li><li><a href="global.html#setLanguage">setLanguage</a></li><li><a href="global.html#setSvgHref">setSvgHref</a></li><li><a href="global.html#shellService">shellService</a></li><li><a href="global.html#shiftFocus">shiftFocus</a></li><li><a href="global.html#svgToCanvas">svgToCanvas</a></li><li><a href="global.html#trackFocusBuilder">trackFocusBuilder</a></li><li><a href="global.html#updateNorthArrow">updateNorthArrow</a></li><li><a href="global.html#useBookmark">useBookmark</a></li><li><a href="global.html#versionCheck">versionCheck</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Wed Oct 24 2018 13:24:54 GMT-0400 (Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
