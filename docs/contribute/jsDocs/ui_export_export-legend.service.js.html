<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: ui/export/export-legend.service.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: ui/export/export-legend.service.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import marked from 'marked';
import removeMd from 'remove-markdown';

// margin of the legend container
const LEGEND_MARGIN = {
    t: 20,
    r: 20,
    b: 20,
    l: 20
};
const SECTION_SPACING = 10; // horizontal spacing between legend sections

const LAYER_GUTTER = 24;
const GROUP_GUTTER = 16;
const INFO_GUTTER = 24;
const ITEM_GUTTER = 8;
const IMAGE_GUTTER = 8;
const SYMBOL_SIZE = 32;

const INFO_FONT_SIZE = 14;

/**
 *
 * @name exportLegendService
 * @module app.ui
 * @requires dependencies
 * @description
 *
 * The `exportLegendService` service generates svg image of the legend breaking into into columns.
 *
 */
angular.module('app.ui').service('exportLegendService', exportLegendService);

function exportLegendService($q, $rootElement, api, LegendBlock, configService, gapiService, graphicsService) {
    const service = {
        generate
    };

    return service;

    /***/

    /**
     * Creates a legend svg graphic from the geoService legend entries.
     * @function generate
     * @param {Number} availableHeight map height, used in legend wraping logic
     * @param {Number} availableWidth width of the legend graphic, should match width of the exported map image
     * @param {Number} preferredSectionWidth width of the individual legend sections inside the legend graphic
     * @return {Promise} promise with resolves with a canvas containing the legend
     */
    function generate(availableHeight = 500, availableWidth = 1500, preferredSectionWidth = 500) {
        // I think this todo is done.
        // TODO: break item names when they overflow even if there are no spaces in the name

        const legendData = extractLegendTree(
            configService.getSync.map.legendBlocks,
            preferredSectionWidth,
            availableWidth
        );

        // resolve with an empty 0 x 0 canvas if there is not layers in the legend
        if (legendData.length === 0) {
            return $q.resolve(graphicsService.createCanvas(0, 0));
        }

        // make a hidden node to construct a legend in
        const hiddenNode = angular.element('&lt;div>').css('visibility', 'hidden');
        $rootElement.append(hiddenNode);

        const legend = SVG(hiddenNode[0]).size(availableWidth, 100);
        const legendSection = legend.group();

        const sectionInfo = {
            count: Math.floor(availableWidth / preferredSectionWidth) || 1, // section count should never be 0
            width: 0,
            height: 0
        };

        let svgLegend; // object containing  arrays of svg elements
        let legendDataCopy; // clone the legendData object since it will be modified in place
        let sectionsUsed = null;

        // keep optimizing while the number of used sections differs from the number of available sections
        while (sectionsUsed !== sectionInfo.count) {
            sectionInfo.count = sectionsUsed || sectionInfo.count;
            sectionInfo.width = getSectionWidth();
            legendDataCopy = angular.copy(extractLegendTree(
                configService.getSync.map.legendBlocks,
                sectionInfo.width,
                availableWidth
            ));

            legendSection.clear();

            // create svg legend
            svgLegend = makeLegend(legendSection, legendDataCopy, sectionInfo.width);

            // optimize; get back the number of sections used
            // if only one column available, ignore optimization
            sectionsUsed =
                sectionInfo.count === 1
                    ? 1
                    : gapiService.gapi.legend.makeLegend(legendDataCopy, sectionInfo.count, availableHeight)
                          .sectionsUsed;
        }

        wraplegend(svgLegend, sectionInfo);

        const totalLegendHeight = sectionInfo.height + LEGEND_MARGIN.t + LEGEND_MARGIN.b;

        // set the height of the legend based on the height of its sections
        legend.height(totalLegendHeight).viewbox(0, 0, availableWidth, totalLegendHeight);

        hiddenNode.remove();

        const localCanvas = document.createElement('canvas'); // create canvas element
        const generationPromise = $q(resolve => {
            canvg(localCanvas, legend.node.outerHTML, {
                ignoreAnimation: true,
                ignoreMouse: true,
                renderCallback: () => resolve(localCanvas)
            });
        });

        return generationPromise;

        /**
         * Helper function which calculates the section width based on the number of sections and margins.
         * @function getSectionWidth
         * @private
         * @return {Number} returns the section width
         */
        function getSectionWidth() {
            return (
                (availableWidth - (LEGEND_MARGIN.l + LEGEND_MARGIN.r + (sectionInfo.count - 1) * SECTION_SPACING)) /
                sectionInfo.count
            );
        }
    }

    /**
     * Wraps the single column legend into several by splitting group and redrawing grouping lines
     * @function wraplegend
     * @private
     * @param {Object} svgLegend generated svg legend in a single columns
     * @param {Object} sectionInfo object with the following section parameters:
     *                 {Number} sectionHeight section height
     *                 {Number} sectionWidth section widht
     *                 {Number} sectionCount number of sections to break the legend into
     */
    function wraplegend(svgLegend, sectionInfo) {
        // create wrap legend sections
        const sections = Array.from(Array(sectionInfo.count)).map(() => svgLegend.container.set());

        let sectionId = 0;
        let currentSection = sections[sectionId];

        const itemStoreSet = svgLegend.container.set(); // create a new set for legend items; set is needed to shift all the items at the same time
        const lineStoreSet = svgLegend.lines; // use a group line set from svgLegend

        // moves legend items from an array to a set
        svgLegend.items.forEach(svg => itemStoreSet.add(svg));

        svgLegend.items.forEach(svg => {
            // wrap the legend at elements previously marked
            if (svg.remember('self').splitBefore) {
                const svgY = svg.y();

                // cut the group lines at the wrapping point
                let i = lineStoreSet.length();
                while (i--) {
                    const line = lineStoreSet.get(i);
                    const [lineX, lineY, lineHeight] = [line.x(), line.y(), line.height()];

                    // if the line starts below the wrapping element, skip
                    if (lineY > svgY) {
                        continue;
                    }

                    // if the line starts above and ends below the wrapping element
                    if (lineY + lineHeight > svgY) {
                        // split the line in two parts: above and below the wrap
                        const up = svgLegend.container
                            .line(lineX, lineY, lineX, Math.min(svgY, sectionInfo.height))
                            .stroke('black');
                        const down = svgLegend.container.line(lineX, svgY, lineX, lineY + lineHeight).stroke('black');

                        line.remove(); // remove original line
                        currentSection.add(up); // store the above part in the  current section
                        lineStoreSet.add(down); // add the below part to the list store for future wrapping (a single line can wrap and be cut multiple time)
                    } else {
                        currentSection.add(line); // if the line fits in the current section, add it there
                    }

                    lineStoreSet.remove(line); // remove that line from the store so it's not processed at further wrappings
                }

                currentSection = sections[++sectionId];

                // shifts legend items and grouped lines up to wrap up current section
                itemStoreSet.dy(-svgY);
                lineStoreSet.dy(-svgY);
            }

            // move a legend item from the bucket store to the current section set
            currentSection.add(svg);
            itemStoreSet.remove(svg);
        });

        // move the left over group lines to the current section
        const lineCount = lineStoreSet.length();
        for (let i = 0; i &lt; lineCount; i++) {
            currentSection.add(lineStoreSet.get(i));
        }

        lineStoreSet.clear();

        // move the sections into proper positions
        sections.forEach((section, index) => {
            const dx = LEGEND_MARGIN.l + sectionInfo.width * index + SECTION_SPACING * index;

            sectionInfo.height = Math.max(sectionInfo.height, section.bbox().h);
            section.dmove(dx, LEGEND_MARGIN.t);

            // draws borders around individual sections
            /*legend.rect(sectionInfo.width, sectionInfo.height)
                .dmove(dx, LEGEND_MARGIN.t)
                .fill('transparent').stroke({ color: 'black', opacity: 0.2 }).back();*/
        });
    }

    /**
     * Creates a single column legend from a legend tree object.
     * @function makeLegend
     * @private
     * @param {Object} container parent svg object
     * @param {Array} items top level item in the legend tree object
     * @param {Number} sectionWidth section width to wrap the item name to
     * @return {Object} object with generated legend items and grouping lines, the total legend height and container reference
     */
    function makeLegend(container, items, sectionWidth) {
        let runningHeight = 0;
        let runningIndent = 0;
        const indentD = 16;

        const itemStore = [];
        const lineSet = container.set();

        items.forEach(item => makeLegendElement(item));

        return {
            container,
            height: runningHeight,
            items: itemStore,
            lines: lineSet
        };

        /**
         * Makes a legend element (header, group, layer, or a symbology item).
         * @function makeLegendElement
         * @private
         * @param {Object} item legend tree item to use
         */
        function makeLegendElement(item) {
            if (item.blockType &amp;&amp; item.blockType === LegendBlock.TYPES.INFO) {
                // IE uses item.name to store its info sections, make a header and add the gutter
                if (item.name !== '') {
                    makeHeader(item, INFO_FONT_SIZE);
                    runningHeight += INFO_GUTTER;
                }
                item.items.forEach(item => {
                    makeInfoItem(item);
                });
            } else if (item.hasOwnProperty('items')) {
                makeLayer(item);
            } else {
                makeSymbolItem(item);
            }
        }

        /**
         * Creates a layer legend and adds it to the graphic.
         * @function makeLayer
         * @param {Object} layer layer symbology from the legend tree
         */
        function makeLayer(layer) {
            const startHeight = runningHeight;

            makeHeader(layer, 18);

            layer.items.forEach(item => {
                if (item.hasOwnProperty('items')) {
                    makeGroup(item);
                } else {
                    makeSymbolItem(item);
                }
            });

            // take away the last symbol item's gutter, adds unneeded whitespace
            runningHeight -= ITEM_GUTTER;

            layer.height = runningHeight - startHeight;

            runningHeight += LAYER_GUTTER;
        }

        /**
         * Creates a group legend and adds it to the graphic.
         * @function makeGroup
         * @private
         * @param {Object} group group symbology from the legend tree
         */
        function makeGroup(group) {
            makeHeader(group, 16);

            const startHeight = runningHeight;
            runningIndent++;

            group.items.forEach(item => {
                makeLegendElement(item);
            });

            runningIndent--;

            const endHeight = runningHeight;
            const line = container
                .line(runningIndent * indentD, startHeight, runningIndent * indentD, endHeight)
                .stroke({ color: 'black', width: 1, opacity: 0.8 });
            lineSet.add(line);

            group.height = runningHeight - startHeight;

            runningHeight += GROUP_GUTTER;
        }

        /**
         * Creates a item legend and adds it to the graphic.
         * @function makeItem
         * @private
         * @param {Object} item item symbology from the legend tree
         * @returns {Object} the item being added
         */
        function makeItem(item) {
            const { name, svgcode } = item;
            const legendItem = container.group().remember('self', item);
            let flow;

            const flowAttributes = {
                'font-family': 'Roboto',
                'font-weight': 'normal',
                'font-size': 14,
                anchor: 'start'
            };

            const imageItem = legendItem
                .group()
                .svg(svgcode)
                .first();
            const imageItemViewbox = imageItem.viewbox();

            /// Use the narrower width as the bound for the image
            if (imageItemViewbox.width > sectionWidth) {
                const imgLookFactor = 0.9; // So it'd have space on left and right for the visual look
                imageItemViewbox.height *= (sectionWidth / imageItemViewbox.width) * imgLookFactor;
                imageItemViewbox.width = sectionWidth * imgLookFactor;
            }

            if (imageItemViewbox.height > SYMBOL_SIZE || imageItemViewbox.width > SYMBOL_SIZE) {
                flow = legendItem
                    .textflow(name, sectionWidth - runningIndent * indentD)
                    .attr(flowAttributes)
                    .dy(-4);

                imageItem.size(imageItemViewbox.width, imageItemViewbox.height).dy(flow.bbox().height + IMAGE_GUTTER);
            } else {
                flow = legendItem
                    .textflow(name, sectionWidth - SYMBOL_SIZE - IMAGE_GUTTER - runningIndent * indentD)
                    .attr(flowAttributes)
                    .dmove(SYMBOL_SIZE + IMAGE_GUTTER, -4); // (x, y)

                // center line if only one
                if (flow.bbox().height &lt; SYMBOL_SIZE) {
                    flow.cy(SYMBOL_SIZE / 2).dy(-4);
                }
            }

            legendItem.move(runningIndent * indentD, runningHeight);
            runningHeight += Math.max(legendItem.rbox().height, imageItemViewbox.height);

            item.height = legendItem.rbox().height;
            item.y = legendItem.y()

            itemStore.push(legendItem);

            return legendItem;
        }

        /**
         * Calls makeItem with item and adds the proper gutter for info sections
         *
         * @function makeInfoItem
         * @private
         * @param {Object} item item symbology from the legend tree
         */
        function makeInfoItem(item) {
            // info sections have a lot of room at the top, take away the gutter space to make them display better
            runningHeight -= INFO_GUTTER;
            makeItem(item);
            runningHeight += INFO_GUTTER;
        }

        /**
         * Calls makeItem with item and adds the proper gutter for symbology
         *
         * @function makeInfoItem
         * @private
         * @param {Object} item item symbology from the legend tree
         */
        function makeSymbolItem(item) {
            makeItem(item);
            runningHeight += ITEM_GUTTER;
        }

        /**
         * Creates a header and adds it to the graphic.
         * @function makeHeader
         * @private
         * @param {Object} item header item from the legend tree
         * @param {Number} size size of the header
         * @returns {Object} the header being added
         */
        function makeHeader(item, size) {
            const name = item.name || '';
            const header = container
                .textflow(name, sectionWidth - runningIndent * indentD)
                .attr({
                    'font-family': 'Roboto',
                    'font-weight': 'normal',
                    'font-size': size,
                    anchor: 'start'
                })
                .remember('self', item)
                .move(runningIndent * indentD, runningHeight); // TODO: add gutter;

            // store header height and its position for future legend wrapping
            item.headerHeight = header.rbox().height;
            item.y = header.y();
            runningHeight += item.headerHeight + size / 2; // TODO: add gutter

            itemStore.push(header);

            return header;
        }
    }

    /**
     * Extract the flat symbology legend tree from the legend blocks
     *
     * @function extractLegendTree
     * @private
     * @param {LegendBlock} legendBlock the root legend block from which to extract the flat symbology tree.
     * @param {Number} sectionWidth the width of the current section
     * @param {Number} availableWidth the max width of the legend
     * @return {Array} a flat array of layers and their symbology items
     */
    function extractLegendTree(legendBlock, sectionWidth, availableWidth) {
        const TYPE_TO_SYMBOLOGY = {
            [LegendBlock.TYPES.NODE]: entry => ({
                name: entry.name,
                items: entry.symbologyStack.stack
            }),
            [LegendBlock.TYPES.GROUP]: entry => ({
                name: entry.name,
                items: extractLegendTree(entry)
            }),
            [LegendBlock.TYPES.SET]: () => null,
            [LegendBlock.TYPES.INFO]: entry => {
                if (entry.infoType === 'image') {
                    const svgCode = _createSVGCode(entry.content);
                    return {
                        name: '',
                        items: [{ name: '', svgcode: svgCode }],
                        blockType: LegendBlock.TYPES.INFO,
                        infoType: entry.infoType
                    };
                } else {
                    const content = entry.layerName || entry.content;

                    // ie can't handle fancy markdown image rendering so we strip markdown entirely
                    if (api.isIE) {
                        return {
                            name: removeMd(content),
                            items: entry.symbologyStack.stack || [],
                            blockType: LegendBlock.TYPES.INFO,
                            infoType: entry.infoType
                        };
                    }

                    const contentToHtml = marked(content);

                    // if no markdown was parsed, return as text
                    if (content === contentToHtml) {
                        return {
                            name: entry.layerName || entry.content,
                            items: entry.symbologyStack.stack || [],
                            blockType: LegendBlock.TYPES.INFO,
                            infoType: entry.infoType
                        };
                    }

                    // restrict width to full legend size
                    const correctedWidth = Math.min(sectionWidth, availableWidth - LEGEND_MARGIN.l - LEGEND_MARGIN.r);

                    const container = document.createElement('div');
                    container.innerHTML = contentToHtml;
                    // restrict width and make invisible
                    container.style.width = `${correctedWidth}px`;
                    container.style.display = 'none';
                    // put in dom to be able to get height
                    document.body.appendChild(container);
                    const height = $(container).height();
                    // This is ECCC, we don't litter here.
                    container.remove();

                    // draw an image to the canvas using this XML SVG wrapper
                    const data = `
                        &lt;svg xmlns="http://www.w3.org/2000/svg" width="${correctedWidth}" height="${height}">
                            &lt;foreignObject width="100%" height="100%">
                                &lt;div xmlns="http://www.w3.org/1999/xhtml" style="font-family: Roboto, 'Helvetica Neue', sans-serif;font-size: ${INFO_FONT_SIZE}px;font-weight: 400;letter-spacing: 0.010em;line-height: 20px;">${contentToHtml}&lt;/div>
                            &lt;/foreignObject>
                        &lt;/svg>
                    `;

                    const img = new Image();

                    // https://bugs.chromium.org/p/chromium/issues/detail?id=294129#c26
                    img.src = 'data:image/svg+xml; charset=utf8, ' + encodeURIComponent(data);

                    // we now have a local image and URL that we can wrap in a legend generator supported svg element
                    return {
                        name: '',
                        items: [
                            {
                                name: '',
                                svgcode: `&lt;svg xmlns:xlink="http://www.w3.org/1999/xlink" height="${height}" width="${correctedWidth}">&lt;image height="${height}" width="${correctedWidth}" xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="${
                                    img.src
                                }">&lt;/image>&lt;/svg>`
                            }
                        ].concat(entry.symbologyStack.stack || []),
                        blockType: LegendBlock.TYPES.INFO,
                        infoType: entry.infoType
                    };
                }
            }
        };

        // TODO: decide if symbology from the duplicated layer should be included in the export image
        let legendTreeData = legendBlock
            .walk(
                entry => (_showBlock(entry) ? TYPE_TO_SYMBOLOGY[entry.blockType](entry) : null),
                entry => (entry.blockType === LegendBlock.TYPES.GROUP ? false : true)
            ) // don't walk entry's children if it's a group
            .filter(a => a !== null);

        let titleBefore = false;
        legendTreeData = legendTreeData
            // filter out non-info blocks with no symbology
            .filter(entry => entry.blockType === LegendBlock.TYPES.INFO || entry.items.length > 0)
            // clear out titles where everything below it (or in between another title) has been removed
            // The two reverses let us filter backwards, making detection of bad titles easier.
            .reverse()
            .filter((entry, index) => {
                if (entry.infoType &amp;&amp; entry.infoType === 'title') {
                    if (index === 0 || titleBefore) {
                        titleBefore = true;
                        return false;
                    }
                    titleBefore = true;
                } else {
                    titleBefore = false;
                }
                return true;
            })
            .reverse();
        return legendTreeData;
    }

    /**
     * Identifies if legend block should be shown in export legend
     *
     * @function _showBlock
     * @private
     * @param {LegendBlock} entry the legend block to be checked whether it should be shown
     * @return {Boolean} true if block should be shown in export legend
     */
    function _showBlock(entry) {
        const exportLegend = configService.getSync.services.export.legend;

        if (entry.controlled &amp;&amp; entry.blockType !== LegendBlock.TYPES.INFO) {
            return exportLegend.showControlledSymbology &amp;&amp; entry.isVisibleOnExport;
        }

        return entry.isVisibleOnExport;
    }

    /**
     * Helper function to get HTML fragment of SVG element provided a URL
     *
     * @function _createSVGCode
     * @private
     * @param {String} link the link of an image
     * @return {String} the HTML fragment of the SVG element created
     */
    function _createSVGCode(link) {
        const img = $rootElement.find(`[src="${link}"]`)[0];

        let svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
        svg.setAttribute('height', img.naturalHeight);
        svg.setAttribute('width', img.naturalWidth);

        let svgimg = document.createElementNS('http://www.w3.org/2000/svg', 'image');
        svgimg.setAttribute('height', img.naturalHeight);
        svgimg.setAttribute('width', img.naturalWidth);
        svgimg.setAttributeNS('http://www.w3.org/1999/xlink', 'href', link);

        svg.appendChild(svgimg);

        return svg.outerHTML;
    }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="app.common.module_displayManager.html">displayManager</a></li><li><a href="app.common.module_stateManager.html">stateManager</a></li><li><a href="app.core.module_common.html">common</a></li><li><a href="app.core.module_ConfigObject.html">ConfigObject</a></li><li><a href="app.core.module_configService.html">configService</a></li><li><a href="app.geo.module_gapiService.html">gapiService</a></li><li><a href="app.geo.module_Geo.html">Geo</a></li><li><a href="app.geo.module_geoService.html">geoService</a></li><li><a href="app.geo.module_identifyService.html">identifyService</a></li><li><a href="app.geo.module_layerRegistry.html">layerRegistry</a></li><li><a href="app.geo.module_LegendBlock.html">LegendBlock</a></li><li><a href="app.geo.module_LegendElementFactory.html">LegendElementFactory</a></li><li><a href="app.geo.module_legendService.html">legendService</a></li><li><a href="app.geo.module_locateService.html">locateService</a></li><li><a href="app.geo.module_mapService.html">mapService</a></li><li><a href="app.geo.module_mapToolService.html">mapToolService</a></li><li><a href="app.geo.module_metadataService.html">metadataService</a></li><li><a href="app.geo.module_rvInitMap.html">rvInitMap</a></li><li><a href="app.geo.module_rvOverviewToggle.html">rvOverviewToggle</a></li><li><a href="app.layout.module_animationService.html">animationService</a></li><li><a href="app.layout.module_layoutService.html">layoutService</a></li><li><a href="app.layout.module_referenceService.html">referenceService</a></li><li><a href="app.layout.module_rvShell.html">rvShell</a></li><li><a href="app.module_core.html">core</a></li><li><a href="app.module_ui.html">ui</a></li><li><a href="app.ui.module_basemapService.html">basemapService</a></li><li><a href="app.ui.module_detailService.html">detailService</a></li><li><a href="app.ui.module_errorService.html">errorService</a></li><li><a href="app.ui.module_expandImageService.html">expandImageService</a></li><li><a href="app.ui.module_ExportComponent.html">ExportComponent</a></li><li><a href="app.ui.module_exportComponentsService.html">exportComponentsService</a></li><li><a href="app.ui.module_exportGenerators.html">exportGenerators</a></li><li><a href="app.ui.module_ExportSize.html">ExportSize</a></li><li><a href="app.ui.module_exportSizesService.html">exportSizesService</a></li><li><a href="app.ui.module_fullScreenService.html">fullScreenService</a></li><li><a href="app.ui.module_geosearchFiltersService.html">geosearchFiltersService</a></li><li><a href="app.ui.module_geosearchService.html">geosearchService</a></li><li><a href="app.ui.module_helpService.html">helpService</a></li><li><a href="app.ui.module_highlightFilter.html">highlightFilter</a></li><li><a href="app.ui.module_layerSource.html">layerSource</a></li><li><a href="app.ui.module_mapNavigationService.html">mapNavigationService</a></li><li><a href="app.ui.module_rvAppbar.html">rvAppbar</a></li><li><a href="app.ui.module_rvBasemap.html">rvBasemap</a></li><li><a href="app.ui.module_rvBasemapItem.html">rvBasemapItem</a></li><li><a href="app.ui.module_rvContentPane.html">rvContentPane</a></li><li><a href="app.ui.module_rvDetails.html">rvDetails</a></li><li><a href="app.ui.module_rvDetailsContent.html">rvDetailsContent</a></li><li><a href="app.ui.module_rvDetailsHeader.html">rvDetailsHeader</a></li><li><a href="app.ui.module_rvDetailsRecordEsrifeature.html">rvDetailsRecordEsrifeature</a></li><li><a href="app.ui.module_rvDetailsRecordEsrifeatureItem.html">rvDetailsRecordEsrifeatureItem</a></li><li><a href="app.ui.module_rvDetailsRecordHtml.html">rvDetailsRecordHtml</a></li><li><a href="app.ui.module_rvDetailsRecordText.html">rvDetailsRecordText</a></li><li><a href="app.ui.module_rvDetectScrollbar.html">rvDetectScrollbar</a></li><li><a href="app.ui.module_rvDragula.html">rvDragula</a></li><li><a href="app.ui.module_rvExportCustomSize.html">rvExportCustomSize</a></li><li><a href="app.ui.module_rvGeosearch.html">rvGeosearch</a></li><li><a href="app.ui.module_rvGeosearchBar.html">rvGeosearchBar</a></li><li><a href="app.ui.module_rvGeosearchBottomFilters.html">rvGeosearchBottomFilters</a></li><li><a href="app.ui.module_rvGeosearchTopFilters.html">rvGeosearchTopFilters</a></li><li><a href="app.ui.module_rvHelpOverlay.html">rvHelpOverlay</a></li><li><a href="app.ui.module_rvHelpSearch.html">rvHelpSearch</a></li><li><a href="app.ui.module_rvLayerListSlider.html">rvLayerListSlider</a></li><li><a href="app.ui.module_rvLegendBlock.html">rvLegendBlock</a></li><li><a href="app.ui.module_rvLoaderFile.html">rvLoaderFile</a></li><li><a href="app.ui.module_rvLoaderMenu.html">rvLoaderMenu</a></li><li><a href="app.ui.module_rvMapnav.html">rvMapnav</a></li><li><a href="app.ui.module_rvMapnavButton.html">rvMapnavButton</a></li><li><a href="app.ui.module_rvMenuLink.html">rvMenuLink</a></li><li><a href="app.ui.module_rvMetadataContent.html">rvMetadataContent</a></li><li><a href="app.ui.module_rvMetadataExpand.html">rvMetadataExpand</a></li><li><a href="app.ui.module_rvMetadataPanel.html">rvMetadataPanel</a></li><li><a href="app.ui.module_rvMorph.html">rvMorph</a></li><li><a href="app.ui.module_rvPlugSlide.html">rvPlugSlide</a></li><li><a href="app.ui.module_rvReverse.html">rvReverse</a></li><li><a href="app.ui.module_rvSettings.html">rvSettings</a></li><li><a href="app.ui.module_rvSettingsContent.html">rvSettingsContent</a></li><li><a href="app.ui.module_rvSidenav.html">rvSidenav</a></li><li><a href="app.ui.module_rvStepperItem.html">rvStepperItem</a></li><li><a href="app.ui.module_rvSymbologyStack.html">rvSymbologyStack</a></li><li><a href="app.ui.module_rvTableDefault.html">rvTableDefault</a></li><li><a href="app.ui.module_rvTableDefaultMenu.html">rvTableDefaultMenu</a></li><li><a href="app.ui.module_rvTablePanel.html">rvTablePanel</a></li><li><a href="app.ui.module_rvToc.html">rvToc</a></li><li><a href="app.ui.module_rvTocEntryControl.html">rvTocEntryControl</a></li><li><a href="app.ui.module_rvTocExpandMenu.html">rvTocExpandMenu</a></li><li><a href="app.ui.module_rvTocVisibilityMenu.html">rvTocVisibilityMenu</a></li><li><a href="app.ui.module_rvToggleSlide.html">rvToggleSlide</a></li><li><a href="app.ui.module_rvToolbox.html">rvToolbox</a></li><li><a href="app.ui.module_rvTooltip.html">rvTooltip</a></li><li><a href="app.ui.module_rvTruncate.html">rvTruncate</a></li><li><a href="app.ui.module_sideNavigationService.html">sideNavigationService</a></li><li><a href="app.ui.module_StepperFactory.html">StepperFactory</a></li><li><a href="app.ui.module_SymbologyStack.html">SymbologyStack</a></li><li><a href="app.ui.module_tableService.html">tableService</a></li><li><a href="app.ui.module_tocService.html">tocService</a></li><li><a href="app.ui.module_tooltipService.html">tooltipService</a></li><li><a href="material.components.button.module_MdButtonDirectiveDecorator.html">MdButtonDirectiveDecorator</a></li><li><a href="material.components.dialog.module_$mdDialog.html">$mdDialog</a></li><li><a href="material.components.icon.module_mdIconDirectiveDecorator.html">mdIconDirectiveDecorator</a></li><li><a href="material.components.menu.module_mdMenuDirective.html">mdMenuDirective</a></li><li><a href="material.components.menu.module_mdSelectDirective.html">mdSelectDirective</a></li><li><a href="material.components.menuBar.module_mdMenuItemDirectiveDecorator.html">mdMenuItemDirectiveDecorator</a></li><li><a href="material.components.select.module_mdSelectMenuDirective.html">mdSelectMenuDirective</a></li><li><a href="material.components.tooltip.module_mdTooltipDirective.html">mdTooltipDirective</a></li></ul><h3>Classes</h3><ul><li><a href="app.core.module_ConfigObject-About.html">About</a></li><li><a href="app.core.module_ConfigObject-Basemap.html">Basemap</a></li><li><a href="app.core.module_ConfigObject-ConfigObject.html">ConfigObject</a></li><li><a href="app.core.module_ConfigObject-Entry.html">Entry</a></li><li><a href="app.core.module_ConfigObject-ExportComponent.html">ExportComponent</a></li><li><a href="app.core.module_ConfigObject-ExportService.html">ExportService</a></li><li><a href="app.core.module_ConfigObject-ExtentSet.html">ExtentSet</a></li><li><a href="app.core.module_ConfigObject-Help.html">Help</a></li><li><a href="app.core.module_ConfigObject-InfoSection.html">InfoSection</a></li><li><a href="app.core.module_ConfigObject-InitialLayerSettings.html">InitialLayerSettings</a></li><li><a href="app.core.module_ConfigObject-LayerNode.html">LayerNode</a></li><li><a href="app.core.module_ConfigObject-Legend.html">Legend</a></li><li><a href="app.core.module_ConfigObject-LegendExportComponent.html">LegendExportComponent</a></li><li><a href="app.core.module_ConfigObject-LegendIsOpen.html">LegendIsOpen</a></li><li><a href="app.core.module_ConfigObject-LodSet.html">LodSet</a></li><li><a href="app.core.module_ConfigObject-Map.html">Map</a></li><li><a href="app.core.module_ConfigObject-NavBar.html">NavBar</a></li><li><a href="app.core.module_ConfigObject-Services.html">Services</a></li><li><a href="app.core.module_ConfigObject-SideMenu.html">SideMenu</a></li><li><a href="app.core.module_ConfigObject-StartPoint.html">StartPoint</a></li><li><a href="app.core.module_ConfigObject-TableIsOpen.html">TableIsOpen</a></li><li><a href="app.core.module_ConfigObject-TileSchema.html">TileSchema</a></li><li><a href="app.core.module_ConfigObject-UI.html">UI</a></li><li><a href="app.core.module_ConfigObject-UILegend.html">UILegend</a></li><li><a href="app.core.module_ConfigObject-VisibilitySet.html">VisibilitySet</a></li><li><a href="app.core.module_configService-Config.html">Config</a></li><li><a href="app.geo.module_LegendBlock-LegendGroup.html">LegendGroup</a></li><li><a href="app.geo.module_LegendBlock-ProxyWrapper.html">ProxyWrapper</a></li><li><a href="app.geo.module_LegendElementFactory-SymbologyControl.html">SymbologyControl</a></li><li><a href="app.ui.module_StepperFactory-Stepper.html">Stepper</a></li><li><a href="app.ui.module_SymbologyStack-SymbologyStack.html">SymbologyStack</a></li><li><a href="app.ui.module_tooltipService-ContainInside.html">ContainInside</a></li><li><a href="app.ui.module_tooltipService-FollowMap.html">FollowMap</a></li><li><a href="app.ui.module_tooltipService-FollowMouse.html">FollowMouse</a></li><li><a href="app.ui.module_tooltipService-Tooltip.html">Tooltip</a></li><li><a href="app.ui.module_tooltipService-TooltipStrategy.html">TooltipStrategy</a></li><li><a href="ConfigObject.UI.html">UI</a></li><li><a href="ExportSize.html">ExportSize</a></li><li><a href="ToggleSymbol.html">ToggleSymbol</a></li><li><a href="Viewer.html">Viewer</a></li><li><a href="ViewerGroup.html">ViewerGroup</a></li></ul><h3>Namespaces</h3><ul><li><a href="app.html">app</a></li><li><a href="app.core.html">core</a></li><li><a href="app.geo.html">geo</a></li><li><a href="app.layout.html">layout</a></li><li><a href="app.ui.html">ui</a></li></ul><h3>Global</h3><ul><li><a href="global.html#$on">$on</a></li><li><a href="global.html#_cfg">_cfg</a></li><li><a href="global.html#addViewer">addViewer</a></li><li><a href="global.html#applyDefault">applyDefault</a></li><li><a href="global.html#attachEvents">attachEvents</a></li><li><a href="global.html#autolink">autolink</a></li><li><a href="global.html#centerAndZoom">centerAndZoom</a></li><li><a href="global.html#configureParser">configureParser</a></li><li><a href="global.html#createCanvas">createCanvas</a></li><li><a href="global.html#createSvg">createSvg</a></li><li><a href="global.html#dateTimeZone">dateTimeZone</a></li><li><a href="global.html#detachEvents">detachEvents</a></li><li><a href="global.html#detectBlur">detectBlur</a></li><li><a href="global.html#detectFocus">detectFocus</a></li><li><a href="global.html#disableCommonPrototypes">disableCommonPrototypes</a></li><li><a href="global.html#elemIsFocusable">elemIsFocusable</a></li><li><a href="global.html#fireRvReady">fireRvReady</a></li><li><a href="global.html#focus">focus</a></li><li><a href="global.html#focusableSearch">focusableSearch</a></li><li><a href="global.html#getBookmark">getBookmark</a></li><li><a href="global.html#getRcsLayerIDs">getRcsLayerIDs</a></li><li><a href="global.html#getTextWidth">getTextWidth</a></li><li><a href="global.html#hasLink">hasLink</a></li><li><a href="global.html#initialBookmark">initialBookmark</a></li><li><a href="global.html#isSameActiveElement">isSameActiveElement</a></li><li><a href="global.html#isValid">isValid</a></li><li><a href="global.html#lastVisibleHistoryElement">lastVisibleHistoryElement</a></li><li><a href="global.html#link">link</a></li><li><a href="global.html#loadRcsLayers">loadRcsLayers</a></li><li><a href="global.html#mapCoordinates">mapCoordinates</a></li><li><a href="global.html#mergeCanvases">mergeCanvases</a></li><li><a href="global.html#northArrow">northArrow</a></li><li><a href="global.html#noSourceLink">noSourceLink</a></li><li><a href="global.html#onFocusin">onFocusin</a></li><li><a href="global.html#onFocusout">onFocusout</a></li><li><a href="global.html#onKeydown">onKeydown</a></li><li><a href="global.html#onKeyup">onKeyup</a></li><li><a href="global.html#onMouseDown">onMouseDown</a></li><li><a href="global.html#picture">picture</a></li><li><a href="global.html#process">process</a></li><li><a href="global.html#ready">ready</a></li><li><a href="global.html#registerPlugin">registerPlugin</a></li><li><a href="global.html#reInitialize">reInitialize</a></li><li><a href="global.html#restoreSession">restoreSession</a></li><li><a href="global.html#RV">RV</a></li><li><a href="global.html#rvCrosshairs">rvCrosshairs</a></li><li><a href="global.html#rvDefaults">rvDefaults</a></li><li><a href="global.html#rvFailureImage">rvFailureImage</a></li><li><a href="global.html#rvFocus">rvFocus</a></li><li><a href="global.html#rvNorthArrow">rvNorthArrow</a></li><li><a href="global.html#rvState">rvState</a></li><li><a href="global.html#setLanguage">setLanguage</a></li><li><a href="global.html#setSvgHref">setSvgHref</a></li><li><a href="global.html#shellService">shellService</a></li><li><a href="global.html#shiftFocus">shiftFocus</a></li><li><a href="global.html#svgToCanvas">svgToCanvas</a></li><li><a href="global.html#trackFocusBuilder">trackFocusBuilder</a></li><li><a href="global.html#updateNorthArrow">updateNorthArrow</a></li><li><a href="global.html#useBookmark">useBookmark</a></li><li><a href="global.html#versionCheck">versionCheck</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Wed Oct 24 2018 13:24:54 GMT-0400 (Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
